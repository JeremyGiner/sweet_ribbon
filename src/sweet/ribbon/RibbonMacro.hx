package sweet.ribbon;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Type.ClassField;
import haxe.macro.TypeTools;
import haxe.macro.ExprTools;
import sweet.ribbon.MappingInfoProvider;
import sweet.ribbon.MappingInfo;

/**
 * ...
 * @author GINER Jeremy
 */
class RibbonMacro {

	macro static public function getClassFieldNameAr( e :ExprOf<Class<Dynamic>> ) {
		// Context.getType( 'MainTest.DataTest1' ) == 

		var s = '';
		switch (e.expr) {
			case EConst(CIdent(cls)):
				switch (Context.getType(cls)) {
					case TInst (_.get() => t, _):
						var path = { name: t.module, sub: t.module == t.name ? null : t.name, pack: t.pack };
						// Create a new instance from the path/type here.
						s = t.name;
					default:
						throw "Invalid type";
				}
			default:
				throw "Invalid argument";
		}
		
		var oClass = TypeTools.getClass(Context.getType( s ));
		var aExpr = new Array<Expr>();
		for ( field in oClass.fields.get() ) {
			
			// Filter non var
			if ( field.kind.getName() != 'FVar' )
				continue;
			
			aExpr.push( macro $v{ field.name } );
		}
		/*
		var myFunc:Function = { 
			expr: macro return $v{['toto','ttiit']},  // actual value
			ret: (macro:Array<String>), // ret = return type
			args:[] // no arguments here
		}
		*/
		/*
		oClass.fields.get().push( {
			name: 'toto',
			pos: Context.currentPos(),
			type: Type.TDynamic( null ),
			doc: 'generated by RibbonMacro',
			isPublic: true,
			kind: FieldKind.FMethod( MethodKind.MethNormal ),
			overloads: null,
			params: null,
			meta: null,
			expr: null,
			
		} );
		*/
		// { type : haxe.macro.Type, pos : haxe.macro.Position, params : Array<haxe.macro.TypeParameter>, overloads : haxe.macro.Ref<Array<haxe.macro.ClassField>>, name : String, meta : haxe.macro.MetaAccess, kind : haxe.macro.FieldKind, isPublic : Bool, expr : Void -> Null<haxe.macro.TypedExpr>, doc : Null<String> } cannot be constructed

		return macro $a{ aExpr };
	}
	
	macro static public function setMappingInfo( 
		eProvider :ExprOf<MappingInfoProvider>, 
		e :ExprOf<Class<Dynamic>> 
	) {
		
		var sClassName = switch (e.expr) {
			case EConst(CIdent(cls)):
				switch (Context.getType(cls)) {
					case TInst (_.get() => t, _):
						//var path = { name: t.module, sub: t.module == t.name ? null : t.name, pack: t.pack };
						t.name;
					default:
						throw "Invalid type";
				}
			default:
				throw "Invalid argument";
		}
		/*
		var str = switch(e.expr) {
            case EConst(CIdent(str)):
                str;
            default:
                throw "type should be string const";
        }
        trace(str);
		*/
/*
src/sweet/ribbon/RibbonMacro.hx:84: { 
expr => EConst(CIdent(DataTest1)), 
pos => #pos(test/MainTest.hx:29: characters 52-61) 
}
*/
		//var sClassName = Type.getClassName( ExprTools.getValue( e ) );
		return macro $eProvider.set( 
			new MappingInfo( 
				Type.getClassName( $e ), 
				RibbonMacro.getClassFieldNameAr( $e )
			)
		);
		return e;
	}
	
}